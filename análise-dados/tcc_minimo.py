# -*- coding: utf-8 -*-
"""tcc_minimo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jfdcNKIStyjOis3baKMFsLzQlb47_5Ra
"""

import numpy as np
import pandas as pd

from scipy.optimize import curve_fit
from scipy.signal import find_peaks

from sklearn.linear_model import ElasticNetCV

import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors

#Matriz de parâmetros Gaussianos deo sensor AS7341 (5 gaussianas)
#y0, A1, xc1, wc1, A2, ...

M1 = np.array([
    [1.332268383173, 2.155785987865, 2.412503866028, 1.813291882335, 2.422132027727, 2.774363852008, 3.013529398091, 1.621375674907],
    [1751.304891415, 3229.505601913, 4871.558442577, 6563.86068389, 6584.206514785, 7475.726435602, 10944.21346491, 91.59100178495],
    [413.585260163, 447.7858604206, 481.9694640897, 517.612156626, 558.1531471353, 590.5645383549, 636.9745525589, 464.1839462236],
    [29.49735745381, 25.41092888266, 31.85033967427, 32.9448223739, 28.83427374052, 31.32906717196, 38.39559512572, 18.36751269218],
    [2.405732767, 38.55265011386, 90.08096291334, 43.73675026492, 162.8419579331, 68.8767373483, 90.57605231055, 13114.67139753],
    [719.0918685288, 646.4522047713, 590.7221535903, 625.3904121815, 688.3067273894, 723.3045315462, 776.8713743478, 685.312138961],
    [19853.66366831, 11.55362772774, 15.01038370111, 13.36712143698, 27.643472642, 15.13333041131, 17.52758685661, 42.09255383924],
    [1.96210732321, 313.1185954184, 40.11382447379, 170.6820720504, 153.399545858, 262.5268938691, 80.32412605151, 158.0552070886],
    [749.3060598769, 790.1900743175, 647.3641531403, 774.2176030594, 738.255304224, 771.263541419, 825.7507205902, 791.3168924262],
    [9.651740748525, 31.74972984432, 14.11328979792, 17.50066934052, 20.43508515717, 16.0274043264, 15.57893503728, 17.27183549922],
    [2.673778022254, 157.4512551081, 125.7368598634, 238.4742904276, 76.80976105005, 0, 145.9221688511, 137.2563348323],
    [685.7154177098, 849.1385040932, 848.8777095066, 815.8525978172, 822.9899185662, 500, 846.0991021515, 840.847130689],
    [7.391948016444, 17.03808237153, 17.01926024402, 28.87357322785, 27.1773794019, 1000, 13.80351341941, 23.29794522526],
    [6.968334095772, 0, 0, 0, 0, 0, 0, 0],
    [788.0170250762, 500, 500, 500, 500, 500, 500, 500],
    [11.26363772195, 1000, 1000, 1000, 1000, 1000, 1000, 1000]
])

df = pd.DataFrame(M1)

#Parâmetros gaussianos: A, xc e wc a partir das linhas da matriz M1

amp = 1   #amplitudade

# area i, selecionando as linhas 1, 4, 7, 10, 13 e 0 de M1
A = M1[[1, 4, 7, 10, 13, 0], :]
xc = M1[[2, 5, 8, 11, 14], :]
wc = amp * M1[[3, 6, 9, 12, 15], :]

#Dados de referência - Vetor B
#Lâmpada = [f1, f2, f3. f4. f5, f6, f7, f8]

LedVerde = np.array([7, 3, 67, 406, 122, 18, 10, 9])
LedAmbar = np.array([34, 25, 58, 28, 619, 2072, 105, 32])
Bulbo = np.array([375, 519, 653, 794, 1068, 1450, 2365, 3074])
BulboFiltro = np.array([303, 385, 378, 361, 801, 1317, 2184, 2837])
LedBranco = np.array([333, 2761, 1111, 2211, 2900, 2656, 1798, 808])

So_list = [LedVerde, LedAmbar, Bulbo, LedBranco]
labels = ['Led Verde', 'Led Ambar', 'Bulbo', 'Led Branco']

#Intervalo de comprimentos de onda
wavelengths = np.linspace(400, 956, 556)

#Vetor intensidade máxima

imax = [
  627841.07688375,
  103.118206484943,
  124.085383242867,
  160.331874179875,
  184.867168074837,
  192.98728685351,
  230.716327475464,
  250.004433922842
];

# Definição da função RF - Soma de 5 gaussianas
# i-ésimo termo -1 pois no Python se começa em 0,1,2,...

def RF(x, m):
    sum_term = sum(A[n-1][m-1] * (np.sqrt(2 / np.pi) / wc[n-1][m-1]) *
                      np.exp(-2 * (x / wc[n-1][m-1] - xc[n-1][m-1] / wc[n-1][m-1])**2) for n in range(1, 6))

    return A[5][m-1] + sum_term

# Gx = b equivale a R*LSR = So

for So, label in zip(So_list, labels):
    R = np.array([[RF(400 + 1*  λ, m) for λ in range(556)] for m in range(1, 9)])
    LSR = np.linalg.lstsq(R, So, rcond=None)[0] #Resolve a equação por mínimos quadrados

# Gráfico

    #Normalização do colormap para cada cor corresponder ao seu comprimento de onda

    plt.figure(figsize=(6, 4))
    colormap = plt.get_cmap('nipy_spectral', len(wavelengths)) #Palheta de cores do espectro eletromag.
    for i in range(len(wavelengths) - 1):
        color = colormap((float(wavelengths[i]) - 400) / (700 - 400) )  # Normaliza o comprimento de onda para o intervalo de [0, 1]
        plt.fill_between(wavelengths[i:i+2],
                         LSR[i:i+2],
                         color=color,
                         alpha=0.6
        )

    plt.plot(wavelengths, LSR, color='black', lw=1)
    plt.xlabel('λ [nm]')
    plt.ylabel('Irradiância [μW/cm²]')
    plt.title(f'Calibração por Mínimos para {label}')
    plt.savefig(f'minimo{label}', dpi=300, bbox_inches='tight')
    plt.show()

from scipy.optimize import nnls
from sklearn.linear_model import Ridge

#Regressão de Ridge

for So, label in zip(So_list, labels):
    R = np.array([[RF(400 + 1*  λ, m) for λ in range(556)] for m in range(1, 9)])

    clf = Ridge(alpha= 0.5,               # Suavização, meio termo, quando mais próximo a zero, mais parecida com a regressão linear
                fit_intercept= True,      # Sem leitura = zero luz, acredita no zero das medições
                positive=True             # Sem irradiância negativa, x>=0
    )
    clf.fit(R, So)                        #Resolve a eq.
    LSR = clf.coef_

#Gráfico

    plt.figure(figsize=(6, 4))
    for i in range(len(wavelengths) - 1):
        color = colormap((float(wavelengths[i]) - 400) / (700 - 400) )  # Normaliza o comprimento de onda para o intervalo de [0, 1]
        plt.fill_between(wavelengths[i:i+2], LSR[i:i+2], color=color, alpha=0.6)

    plt.plot(wavelengths, LSR, color='black', lw=1)  # Adiciona a linha da curva
    plt.xlabel('λ [nm]')
    plt.ylabel('Irradiância [μW/cm²]')
    plt.title(f'Calibração por Ridge para {label}')
    plt.savefig(f'minimo{label}', dpi=300, bbox_inches='tight')
    plt.show()

from mpl_toolkits.mplot3d import Axes3D

#Variar entre os canais f
f = np.arange(1, 9)

# Criação das matrizes para o gráfico
X, M = np.meshgrid( np.linspace(400, 955, 401), f)

#Inicializando RF
RF_values = np.zeros_like(X)

# Calcular RF[x, m] para cada combinação de x e m
for i in range(len( np.linspace(400, 955, 401))):
  for j in range(len(f)):
    RF_values[j, i] = RF( np.linspace(400, 955, 401)[i], f[j])

#Gráfico 3D
fig = plt.figure(figsize =(12, 8))
ax = fig.add_subplot(111, projection = '3d')

#Plot das linhas para cada valor de m
for i in range(len(f)):
  ax.plot ( np.linspace(400, 955, 401) , np.full_like( np.linspace(375, 955, 401), f[i]), RF_values[i, :], label = f'f={f[i]}')

ax.set_xlabel('λ[nm]')
ax.set_ylabel('canais $f_N$')
ax.set_zlabel('Irradiância [μW/cm²]')
ax.set_title('Curvas dos Canais $f_N$')
ax.set_box_aspect([2, 4, 1])
ax.legend(loc = 'upper left')
plt.show()

x = np.linspace(400, 955, 401)
# Definindo a função PM em Python
def PM(f, x):
    results = []

    for i in x:
        sum_term = sum([RF(i, m ) * f[m-1]for m in range(1, 9, 1)])
        results.append(sum_term)
    return np.array(results)

# Plotando os gráficos
for So, label in zip(So_list, labels):
    pm_values = PM(So, x) # Passa  So lampada e  x os comprimentos de onda
    plt.figure(figsize=(6, 4))

    for i in range(len(x) - 1):
        color = colormap((float(x[i]) - 400) / (700 - 400) )  # Normaliza o comprimento de onda para o intervalo de [0, 1]
        plt.fill_between(x[i:i+2], pm_values[i:i+2], color=color, alpha=0.6)

    plt.plot(x, pm_values, color='black', lw=1)  # Adiciona a linha da curva
    plt.xlabel('λ[nm]')
    plt.ylabel('Contagens')
    plt.title(f'Calibração por Soma para {label}')
    plt.savefig(f'soma{label}', dpi=300, bbox_inches='tight')
    plt.show()

#Polinômio da função CLEAR

def CL (x):
  y = (-6131.211631462 + (47.430700152195 * x) - (0.14280312072533 * (x**2)) +
   (0.00021089376188763 * (x**3)) - (1.5168384249637 * (10**-7)) * (x**4) + (4.2318996462107 * (10**-11) * x**5))

  return y

#Gráfico

plt.plot(x, CL(x))
plt.xlabel('λ[nm]')
plt.ylabel('contagens')
plt.fill_between(x, CL(x), color='lightblue', alpha=0.5)  # Colore a área abaixo da curva com azul claro
plt.fill_between(x, CL(x), color ='lightblue', alpha = 0.5)
plt.title('Ajuste Polinomial de 5ª ordem do CLEAR')
equation = r"$CL(\lambda) = \sum_{i=0}^{5} a_i \lambda^i$"
plt.text(600, 50, equation, fontsize=14, color='black')
plt.show()

from scipy.stats import norm

# Definir as funções densidade de probabilidade (PDFs)
def Mel(x):
    return (101.86 * 10**-3) * 2 * norm.pdf(x, 489.32, 35.13)

def Cya(x):
    return (100.71 * 10**-3) * 2 * norm.pdf(x, 444.12, 21.76)

def Rho(x):
    return (103.36 * 10**-3) * 2 * norm.pdf(x, 506.18, 41.73)

def Chl(x):
    return (100.22 * 10**-3) * 2 * norm.pdf(x, 537.96, 47.12)

def Ery(x):
    return (100.03 * 10**-3) * 2 * norm.pdf(x, 564.27, 50.04)

# Gerar valores de x [nm]
x = np.linspace(375, 955, 401)

# Calcular as PDFs
mel_values = Mel(x)
cya_values = Cya(x)
rho_values = Rho(x)
chl_values = Chl(x)
ery_values = Ery(x)

# Plotar as PDFs
plt.plot(x, mel_values, label='Mel')
plt.plot(x, cya_values, label='Cya')
plt.plot(x, rho_values, label='Rho')
plt.plot(x, chl_values, label='Chl')
plt.plot(x, ery_values, label='Ery')

plt.xlabel('x')
plt.ylabel('PDF')
plt.legend()
plt.title('Funções de Densidade de Probabilidade (PDFs)')
plt.show()